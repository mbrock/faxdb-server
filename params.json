{"name":"Faxdb-server","tagline":"Node version of faxdb-server","body":"\r\n# Fax: a semi-centralized synchronization system\r\n\r\n[![Circle CI](https://circleci.com/gh/mbrock/faxdb-server.svg?style=svg)](https://circleci.com/gh/mbrock/faxdb-server)\r\n\r\nFax is concerned with synchronizing facts in real-time among web\r\nclients, using a central consensus server, and with eventual consistency\r\nfeeding some slower indexing database.\r\n\r\nTechnically, it's similar to a Git repository server, except made for\r\nreal-time web app synchronization via JSON.\r\n\r\n## Values\r\n\r\n1. Simplicity: it should be possible to understand, because if it breaks\r\n   or misbehaves, your users will be immediately confused.\r\n\r\n2. Correctness: the behavior of the system should be clear and\r\n   well-defined, and there should be good reason to believe that the\r\n   implementation does what it's supposed to.\r\n\r\n3. Speed: the faster the entire network can synchronize, the better,\r\n   though latency is optimized for quick acknowledgement to the user.\r\n\r\n4. Portability: simple protocols and a basic implementation in\r\n   plain JavaScript.\r\n\r\n5. Offline-friendliness: the ability to do work without constant\r\n   synchronization is good for robustness and speed and enables new\r\n   use cases.\r\n\r\n6. Transparency: the system should be easy to trace, analyze,\r\n   and recover.\r\n\r\n## Structure\r\n\r\nA system instance consists of a server and a set of clients.\r\nEach client is logged in as a user.  The server has many different\r\n\"documents\" with universally unique identifiers.  Such a document is\r\ndefined by a sequence of committed operations, much like a Git\r\nrepository.\r\n\r\nInitially, we will require these repositories to be linear, having no\r\nbranches, but relaxing that requirement is an interesting possibility.\r\nWe use Git-style content addressing to ensure integrity and ordering.\r\nThus clients may need to \"rebase\" their operations if their document has\r\nchanged, in effect pessimistic locking.  If the server has some\r\nunderstanding of the semantics of a document, it can be told to\r\n\"auto-rebase\" in specific ways, which reduces round-trips.\r\n\r\nThere is also a notion of state, defined for each document version by a\r\ndeterministic function applied iteratively to the operation sequence,\r\ngiven an initial state.  This is so that clients can do a \"shallow\r\nclone\" of a document by downloading its state and the hash of its most\r\nrecent commit.  When synchronizing later, they can request the operation\r\nsuffixes necessary to update their saved document states.\r\n\r\nFor example, a document representing a folder might consist of add and\r\nremove operations, and the state is defined as the resulting folder.\r\nThe server caches that state in some way, so the client can just get the\r\nlatest folder contents.\r\n\r\n## Protocol\r\n\r\nThe server exposes this API:\r\n\r\n| Request                   | Input                  | Output                            | Content-Type      |\r\n|---------------------------|------------------------|-----------------------------------|-------------------|\r\n| `GET /`                   | ---                    | `{ [document]: { head, state } }` | application/json  |\r\n| `GET /:document:`         | ---                    | `{ head, state }`                 | application/json  |\r\n| `POST /:document:`        | `{ hash, operations }` | ---                               | application/json  |\r\n| `GET /:document:/:hash:`  | ---                    | `{ head, operations }`            | text/event-stream |\r\n\r\nThe metavariable `head` is a cryptographic hash of the document,\r\ndescribed below.\r\n\r\nThe root path content is based on HTTP headers, which presumably are\r\nadded based by a proxy based on user authentication. For example\r\n`X-User: john` makes the root return all the documents that user `john`\r\nis interested in).\r\n\r\n### Hashing\r\n\r\nHashing is based on the JSON representations of operations in a\r\nwell-defined and incremental way:\r\n\r\n    f(operations, old-hash) = hash(old-hash ++ to-json(operations))\r\n\r\nThe `hash` function is SHA256 truncated to 160 bits, rendered as 40\r\ncharacters of lowercase hexadecimal ASCII/UTF-8.  (Git hashes are\r\nsimilar but with 40 chars of SHA1, which is considered feasibly\r\ncrackable, so SHA256/160 seems reasonable enough.)\r\n\r\n### Inserting\r\n\r\nA request to `POST /:document:` will be `200 OK` if the server accepts\r\nand commits the provided hash and operations, judging them a valid\r\nextension of the document.\r\n\r\nIf the server finds that the given hash is incorrect---i.e., not the\r\nsame as the server's calculation of `f(new-operations, old-hash)` (as\r\ndescribed above)---then the response status code is `409 Conflict`, and\r\nthe response body is, conveniently, the info needed for a client to\r\nrebase: namely, the server's committed operation suffix after\r\n`old-hash`, in the form `{ operations }`.\r\n\r\n### Streaming\r\n\r\nNot too complicated.\r\n\r\n## Server Configuration\r\n\r\nThe server is library code.  You instantiate it with function parameters\r\nfor configuring:\r\n\r\n1. how to retrieve all the documents relevant to a root request;\r\n2. how to execute operations, by validating and (immutably) updating\r\n   state;\r\n3. how to load documents and update them transactionally (e.g. in memory\r\n   or an RDBMS); and\r\n4. how to store and load state.\r\n\r\n```js\r\nfax({\r\n  pickDocuments,\r\n  executeOperations,\r\n  commitStore: {\r\n    saveCommit,\r\n    loadCommitSuffix,\r\n  },\r\n  stateStore: {\r\n    saveState,\r\n    loadState\r\n  }\r\n})\r\n```\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}